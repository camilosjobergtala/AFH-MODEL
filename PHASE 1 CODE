# â”€â”€ AFH* Proyecto Eclipse â€“ VersiÃ³n Base con Copilot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Estructura inicial para detectar pliegue autopsÃ­quico
# Autor: Camilo Alejandro SjÃ¶berg Tala

import numpy as np
import networkx as nx
from sklearn.metrics import mutual_info_score
import matplotlib.pyplot as plt
import csv

# â”€â”€ 1. Calcular Îº_topo (curvatura estructural del grafo cerebral) â”€
def calcular_kappa_topo(grafo):
    curvaturas = []
    for u, v in grafo.edges():
        peso = grafo[u][v]['weight']
        vecinos_u = set(grafo.neighbors(u))
        vecinos_v = set(grafo.neighbors(v))
        interseccion = len(vecinos_u & vecinos_v)
        total = len(vecinos_u) + len(vecinos_v)
        curvaturas.append(peso * interseccion / max(1, total))
    return np.mean(curvaturas)

# â”€â”€ 2. Calcular Î¦_H (integraciÃ³n funcional usando mutual information) â”€
def calcular_phi_H(series):
    scores = []
    for i in range(series.shape[1] - 1):
        scores.append(mutual_info_score(series[:, i], series[:, i+1]))
    return np.mean(scores)

# â”€â”€ 3. Calcular Î”PCI (complejidad pre/post perturbaciÃ³n) â”€
def calcular_delta_PCI(par):
    def lz(signal):
        binario = ''.join('1' if x > np.median(signal) else '0' for x in signal)
        return len(binario) / (len(set(binario)) + 1e-10)
    return abs(lz(par[0]) - lz(par[1]))

# â”€â”€ 4. Detectar colapso del pliegue autopsÃ­quico â”€
def detectar_colapso(variables):
    fallan = []
    if variables['Îº_topo'] < 0.5:
        fallan.append('Îº_topo')
    if variables['Î¦_H'] < 1.0:
        fallan.append('Î¦_H')
    if variables['Î”PCI'] < 0.1:
        fallan.append('Î”PCI')
    return {
        "colapso": len(fallan) > 0,
        "fallan": fallan
    }

# â”€â”€ 5. Detectar singularidad convergente â”€
def detectar_singularidad_convergente(prev_vars, curr_vars):
    condiciones = [
        prev_vars['Îº_topo'] < 0.5 and curr_vars['Îº_topo'] >= 0.5,
        prev_vars['Î¦_H'] < 1.0 and curr_vars['Î¦_H'] >= 1.0,
        prev_vars['Î”PCI'] < 0.1 and curr_vars['Î”PCI'] >= 0.1,
    ]
    return sum(condiciones) >= 2  # al menos 2 de 3 se cumplen

# â”€â”€ 6. Detectar singularidad divergente â”€
def detectar_singularidad_divergente(prev_vars, curr_vars):
    condiciones = [
        prev_vars['Îº_topo'] >= 0.5 and curr_vars['Îº_topo'] < 0.5,
        prev_vars['Î¦_H'] >= 1.0 and curr_vars['Î¦_H'] < 1.0,
        prev_vars['Î”PCI'] >= 0.1 and curr_vars['Î”PCI'] < 0.1,
    ]
    return sum(condiciones) >= 2  # al menos 2 de 3 se cumplen

# â”€â”€ 7. Detectar estabilidad del pliegue â”€
def detectar_estabilidad(estados, min_duracion=3):
    """
    Detecta periodos donde todas las variables estÃ¡n sobre umbral por al menos min_duracion pasos.
    Devuelve lista de Ã­ndices centrales de los periodos estables.
    """
    umbrales = {'Îº_topo': 0.5, 'Î¦_H': 1.0, 'Î”PCI': 0.1}
    estables = []
    actual = []
    for i, v in enumerate(estados):
        if v['Îº_topo'] >= umbrales['Îº_topo'] and v['Î¦_H'] >= umbrales['Î¦_H'] and v['Î”PCI'] >= umbrales['Î”PCI']:
            actual.append(i)
        else:
            if len(actual) >= min_duracion:
                estables.append(actual[len(actual)//2])  # Ã­ndice central del periodo estable
            actual = []
    if len(actual) >= min_duracion:
        estables.append(actual[len(actual)//2])
    return estables

if __name__ == "__main__":
    # 1. Generar lista temporal de estados fluctuantes
    estados = [
        {'Îº_topo': 0.3, 'Î¦_H': 0.7, 'Î”PCI': 0.05},  # bajo umbral
        {'Îº_topo': 0.4, 'Î¦_H': 0.8, 'Î”PCI': 0.08},  # bajo umbral
        {'Îº_topo': 0.6, 'Î¦_H': 1.1, 'Î”PCI': 0.12},  # subida (activaciÃ³n pliegue)
        {'Îº_topo': 0.7, 'Î¦_H': 1.2, 'Î”PCI': 0.13},  # estabilidad interna
        {'Îº_topo': 0.65, 'Î¦_H': 1.05, 'Î”PCI': 0.11},# estabilidad interna
        {'Îº_topo': 0.45, 'Î¦_H': 0.9, 'Î”PCI': 0.07}, # bajada (colapso)
        {'Îº_topo': 0.35, 'Î¦_H': 0.6, 'Î”PCI': 0.03}  # bajo umbral
    ]

    # 2. Aplicar funciones de detecciÃ³n en cada par de pasos
    convergentes = []
    divergentes = []
    eventos = []
    for i in range(1, len(estados)):
        prev_vars = estados[i-1]
        curr_vars = estados[i]
        if detectar_singularidad_convergente(prev_vars, curr_vars):
            print(f"ðŸ”¹ Singularidad convergente detectada en t={i} (activaciÃ³n pliegue)")
            convergentes.append(i)
            eventos.append({'tipo': 'convergente', 't': i})
        if detectar_singularidad_divergente(prev_vars, curr_vars):
            print(f"ðŸ”¹ Singularidad divergente detectada en t={i} (colapso pliegue)")
            divergentes.append(i)
            eventos.append({'tipo': 'divergente', 't': i})

    # 3. Detectar estabilidad interna (â‰¥3 pasos en secuencia)
    estables = detectar_estabilidad(estados, min_duracion=3)
    for idx in estables:
        print(f"ðŸ”¹ Estabilidad interna detectada en t={idx}")

    # 4. VisualizaciÃ³n del proceso
    tiempos = list(range(len(estados)))
    kappa = [e['Îº_topo'] for e in estados]
    phi = [e['Î¦_H'] for e in estados]
    pci = [e['Î”PCI'] for e in estados]

    plt.figure(figsize=(10, 6))
    plt.plot(tiempos, kappa, '-o', label='Îº_topo')
    plt.plot(tiempos, phi, '-o', label='Î¦_H')
    plt.plot(tiempos, pci, '-o', label='Î”PCI')

    # LÃ­neas horizontales de umbral
    plt.axhline(0.5, color='blue', linestyle='dotted', linewidth=1, label='Umbral Îº_topo')
    plt.axhline(1.0, color='orange', linestyle='dotted', linewidth=1, label='Umbral Î¦_H')

    # Marcar transiciones convergentes
    plt.scatter(convergentes, [kappa[i] for i in convergentes], color='green', s=120, marker='^', label='Convergente')
    # Marcar transiciones divergentes
    plt.scatter(divergentes, [kappa[i] for i in divergentes], color='red', s=120, marker='v', label='Divergente')
    # Marcar estabilidad interna
    plt.scatter(estables, [kappa[i] for i in estables], color='purple', s=120, marker='*', label='Estabilidad')

    plt.xlabel('Tiempo')
    plt.ylabel('Valor')
    plt.title('EvoluciÃ³n de Îº_topo, Î¦_H y Î”PCI con transiciones y estabilidad')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # 5. Exportar eventos como CSV
    with open('eventos_pah.csv', 'w', newline='', encoding='utf-8') as csvfile:
        fieldnames = ['tipo', 't']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for evento in eventos:
            writer.writerow(evento)
        for idx in estables:
            writer.writerow({'tipo': 'estabilidad', 't': idx})

    print("Eventos exportados a eventos_pah.csv")
